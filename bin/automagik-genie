#!/usr/bin/env node

const { validateClaude } = require('../lib/claude-cli-check.js');
const { init } = require('../lib/init.js');
const path = require('path');
const { spawn } = require('child_process');
const readline = require('readline');
const fs = require('fs').promises;

// Constants - single source of truth for all repeated values
const CONSTANTS = {
  WISH_TEXT: `/wish Analyze this codebase including .claude-backup configurations, detect tech stack, understand patterns, and propose custom development agents based on project needs`,
  EXIT_CODE: {
    SUCCESS: 0,
    ERROR: 1
  },
  MESSAGES: {
    GENIE_TITLE: 'üßû Automagik Genie - Universal AI Development Companion',
    INIT_START: 'üßû Initializing Automagik Genie...',
    INIT_SUCCESS: '‚ú® Genie successfully initialized!',
    ANALYSIS_START: 'üßû Starting intelligent codebase analysis...',
    ANALYSIS_COMPLETE: '‚ú® Analysis complete!',
    MANUAL_AVAILABLE: 'üí° Manual analysis available - run when ready:',
    AUTO_START_FAILED: '‚ö†Ô∏è  Could not auto-start analysis:',
    UNKNOWN_COMMAND: '‚ùå Unknown command:',
    INIT_FAILED: '‚ùå Initialization failed:',
    UNEXPECTED_ERROR: '‚ùå Unexpected error:',
    FATAL_ERROR: '‚ùå Fatal error:',
    HELP_SUGGESTION: 'üí° Run: npx automagik-genie --help',
    TROUBLESHOOTING: 'üîß Troubleshooting:',
    HAPPY_CODING: 'Happy coding! üßû‚ú®'
  }
};

// Utility functions
const logSpacing = () => console.log('');
const logWithSpacing = (message) => {
  logSpacing();
  console.log(message);
  logSpacing();
};
const exitWithError = (message) => {
  console.error(message);
  process.exit(CONSTANTS.EXIT_CODE.ERROR);
};

const showHelp = () => {
  console.log(CONSTANTS.MESSAGES.GENIE_TITLE);
  logSpacing();
  console.log('Usage:');
  console.log('  npx automagik-genie init            Initialize Genie (smart merge - preserves existing content)');
  console.log('  npx automagik-genie init --legacy   Use legacy mode (destructive replacement)');
  console.log('  npx automagik-genie update          Update agents and hooks to latest version');
  console.log('  npx automagik-genie rollback        Rollback to a previous backup');
  console.log('  npx automagik-genie status          Show system status and available updates');
  console.log('  npx automagik-genie cleanup         Clean up old backups and cache');
  console.log('  npx automagik-genie --help          Show this help message');
  logSpacing();
  console.log('Requirements:');
  console.log('  - Claude CLI must be installed and authenticated');
  console.log('  - Run in any project directory (any programming language)');
  logSpacing();
  console.log('What it does:');
  console.log('  ‚ú® Analyzes your codebase (any language: Go, Rust, Python, JS, etc.)');
  console.log('  ü§ñ Creates project-specific AI agents');
  console.log('  üéØ Provides /wish command for development assistance');
  console.log('  üîß Installs optional development workflow hooks');
  console.log('  üõ°Ô∏è  PRESERVES your custom agents, hooks, and configurations');
  console.log('  üîÑ Smart merge - no data loss, only updates what needs updating');
  logSpacing();
  console.log('After initialization:');
  console.log('  /wish "analyze this codebase"');
  console.log('  /wish "add authentication system"');
  console.log('  /wish "fix failing tests"');
  logSpacing();
  console.log('Opus model:');
  console.log('  Automatically prompts during init for Claude Opus usage');
  console.log('  Provides enhanced reasoning and superior code analysis');
  logSpacing();
  console.log('Update examples:');
  console.log('  npx automagik-genie update --dry-run    Preview updates');
  console.log('  npx automagik-genie update --agents-only Update only agents');
  console.log('  npx automagik-genie status --check-remote Check for updates');
  logSpacing();
  console.log('Smart merge vs Legacy:');
  console.log('  üõ°Ô∏è  Smart merge (default): Preserves ALL your custom content');
  console.log('  ‚ö†Ô∏è  Legacy mode: Destructive - backs up and replaces everything');
  logSpacing();
  console.log('Learn more: https://github.com/namastexlabs/automagik-genie');
};

const showPostInitInstructions = () => {
  console.log('üîç The analyzer agent will auto-detect your tech stack');
  logSpacing();
  console.log('üéØ Available commands:');
  console.log('   /wish "add feature X"     - Request new functionality');  
  console.log('   /wish "fix failing tests" - Debug and repair issues');
  console.log('   /wish "optimize performance" - Improve code efficiency');
  logSpacing();
  console.log('üìö Check .claude/hooks/examples/ for optional workflow automation');
  logSpacing();
  console.log(CONSTANTS.MESSAGES.HAPPY_CODING);
};

/**
 * Build Claude command with conditional permissions, model selection, and wish text
 * @param {boolean} skipPermissions - Whether to add --dangerously-skip-permissions flag
 * @param {boolean} useOpus - Whether to use Claude Opus model
 * @param {string} wishText - The wish command text to execute
 * @returns {string} Complete Claude command string
 */
const buildClaudeCommand = (skipPermissions, useOpus, wishText) => {
  let command = 'claude';
  
  if (skipPermissions) {
    command += ' --dangerously-skip-permissions';
  }
  
  if (useOpus) {
    command += ' --model opus';
  }
  
  command += ` "${wishText}"`;
  return command;
};

/**
 * Show manual Claude command instructions with consistent formatting
 * @param {boolean} skipPermissions - Whether instructions should include skip permissions flag
 * @param {boolean} useOpus - Whether instructions should include Opus model flag
 * @param {string} context - Context for the instructions (e.g., 'error', 'completion')
 */
const showManualInstructions = (skipPermissions, useOpus = false, context = 'default') => {
  const command = buildClaudeCommand(skipPermissions, useOpus, CONSTANTS.WISH_TEXT);
  
  console.log(CONSTANTS.MESSAGES.MANUAL_AVAILABLE);
  console.log(`   ${command}`);
};

/**
 * Handle Claude process errors with consistent messaging
 * @param {Error} error - The error object from Claude process
 * @param {boolean} skipPermissions - Whether skip permissions was used
 * @param {boolean} useOpus - Whether Opus model was selected
 */
const handleClaudeError = (error, skipPermissions, useOpus) => {
  logSpacing();
  console.log(CONSTANTS.MESSAGES.AUTO_START_FAILED);
  
  if (error.code === 'ENOENT') {
    console.log('   Claude CLI not found in PATH');
    console.log('   Please ensure Claude CLI is installed and authenticated');
  } else {
    console.log(`   ${error.message}`);
  }
  logSpacing();
  showManualInstructions(skipPermissions, useOpus, 'error');
  logSpacing();
  showPostInitInstructions();
};

/**
 * Handle Claude process completion with consistent messaging
 * @param {number} code - Exit code from Claude process
 * @param {boolean} skipPermissions - Whether skip permissions was used
 * @param {boolean} useOpus - Whether Opus model was selected
 */
const showAnalysisCompletion = (code, skipPermissions, useOpus) => {
  logSpacing();
  
  if (code === CONSTANTS.EXIT_CODE.SUCCESS) {
    console.log(CONSTANTS.MESSAGES.ANALYSIS_COMPLETE);
  } else {
    showManualInstructions(skipPermissions, useOpus, 'completion');
  }
  logSpacing();
  showPostInitInstructions();
};

/**
 * Prompt user for permission skip option
 * @returns {Promise<boolean>} True if user wants to skip permissions
 */
const promptForPermissionSkip = () => {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    console.log('üîê Claude CLI Permission Options:');
    logSpacing();
    console.log('Claude CLI can run with enhanced permissions for full functionality,');
    console.log('or with restricted permissions for security-conscious environments.');
    logSpacing();
    
    rl.question('Do you want to start with "--dangerously-skip-permissions"? (y/N): ', (answer) => {
      rl.close();
      // Default to 'no' if user just hits enter or explicitly says no
      const skipPermissions = answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes';
      
      if (skipPermissions) {
        console.log('‚úÖ Will start Claude with --dangerously-skip-permissions');
      } else {
        console.log('‚úÖ Will start Claude with full permissions');
      }
      logSpacing();
      
      resolve(skipPermissions);
    });
  });
};

/**
 * Prompt user for statusline setup option
 * @returns {Promise<boolean>} True if user wants to add statusline
 */
const promptForStatusline = () => {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    console.log('üßû Genie Statusline Configuration:');
    logSpacing();
    console.log('Would you like to add Genie statusline to Claude Code?');
    console.log('This adds a magical status bar showing Genie activity and git info.');
    logSpacing();
    
    rl.question('Add Genie statusline to Claude? (Y/n): ', (answer) => {
      rl.close();
      // Default to 'yes' if user just hits enter
      const addStatusline = answer === '' || 
                           answer.toLowerCase() === 'y' || 
                           answer.toLowerCase() === 'yes';
      
      if (addStatusline) {
        console.log('‚úÖ Will configure Genie statusline');
      } else {
        console.log('‚è≠Ô∏è  Skipping statusline configuration');
      }
      logSpacing();
      
      resolve(addStatusline);
    });
  });
};

/**
 * Prompt user for Opus model selection
 * @returns {Promise<boolean>} True if user wants to use Opus model
 */
const promptForOpus = () => {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    console.log('üöÄ Model Selection:');
    logSpacing();
    console.log('Would you like to use Claude Opus for enhanced development assistance?');
    console.log('Opus provides superior reasoning and code analysis capabilities.');
    logSpacing();
    
    rl.question('Use Claude Opus model? (Y/n): ', (answer) => {
      rl.close();
      // Default to 'yes' if user just hits enter
      const useOpus = answer === '' || 
                     answer.toLowerCase() === 'y' || 
                     answer.toLowerCase() === 'yes';
      
      if (useOpus) {
        console.log('‚úÖ Will use Claude Opus model');
      } else {
        console.log('‚è≠Ô∏è  Will use default model');
      }
      logSpacing();
      
      resolve(useOpus);
    });
  });
};

/**
 * Configure statusline in Claude settings.json
 * @param {string} targetPath - The project directory path
 * @returns {Promise<void>}
 */
const configureStatusline = async (targetPath) => {
  const settingsPath = path.join(targetPath, '.claude', 'settings.json');
  const statuslineScriptPath = path.join(targetPath, '.claude', 'genie-statusline.js');
  
  try {
    // Check if the statusline script exists
    try {
      await fs.access(statuslineScriptPath);
    } catch {
      console.log('‚ö†Ô∏è  Statusline script not found at .claude/genie-statusline.js');
      console.log('   Statusline configuration skipped.');
      return;
    }
    
    let settings = {};
    
    // Try to read existing settings
    try {
      const existingContent = await fs.readFile(settingsPath, 'utf8');
      settings = JSON.parse(existingContent);
    } catch (error) {
      // File doesn't exist or is invalid JSON, start with empty object
      console.log('üìù Creating new settings.json file...');
    }
    
    // Configure statusline based on existing settings
    if (settings.statusLine) {
      // Statusline already exists
      const existingCommand = settings.statusLine.command;
      
      // Check if it's already our genie statusline
      if (existingCommand && existingCommand.includes('genie-statusline')) {
        console.log('‚ú® Genie statusline already configured!');
        return;
      }
      
      // Another statusline exists - we should chain them
      console.log('üîó Existing statusline found, creating wrapper to chain both...');
      
      // Update the genie-statusline.js to chain with existing command
      const wrapperContent = `#!/usr/bin/env node

/**
 * üßû Genie Statusline Wrapper with Chaining
 * Runs both Genie statusline and existing statusline
 */

const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

// Get stdin data
let stdinData = '';
process.stdin.setEncoding('utf8');

process.stdin.on('data', (chunk) => {
  stdinData += chunk;
});

process.stdin.on('end', async () => {
  const projectRoot = path.dirname(__dirname);
  const localStatusline = path.join(projectRoot, 'lib', 'statusline.js');
  const outputs = [];
  
  try {
    // Run Genie statusline
    if (fs.existsSync(localStatusline)) {
      const result = await runCommand('node', [localStatusline], stdinData);
      if (result) outputs.push(result);
    } else {
      const result = await runCommand('npx', ['-y', 'automagik-genie', 'statusline'], stdinData);
      if (result) outputs.push(result);
    }
    
    // Run existing statusline command
    const existingCommand = ${JSON.stringify(existingCommand)};
    if (existingCommand) {
      try {
        // Parse command (might be "node script.js" or just "script")
        const parts = existingCommand.split(' ');
        const cmd = parts[0];
        const args = parts.slice(1);
        const result = await runCommand(cmd, args, stdinData);
        if (result) outputs.push(result);
      } catch (e) {
        // Silently ignore if existing command fails
      }
    }
    
  } catch (error) {
    outputs.push('üßû Genie statusline error: ' + error.message);
  }
  
  console.log(outputs.filter(o => o).join('\\n'));
});

function runCommand(command, args, input) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, {
      shell: process.platform === 'win32',
      windowsHide: true,
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    let stdout = '';
    
    child.stdout.on('data', (data) => {
      stdout += data.toString();
    });
    
    child.on('error', reject);
    
    child.on('close', (code) => {
      resolve(stdout.trim());
    });
    
    if (input) {
      child.stdin.write(input);
      child.stdin.end();
    }
  });
}`;
      
      await fs.writeFile(statuslineScriptPath, wrapperContent, 'utf8');
      await fs.chmod(statuslineScriptPath, 0o755);
    }
    
    // Update settings with our statusline
    settings.statusLine = {
      type: "command",
      command: "node .claude/genie-statusline.js"
    };
    
    // Write updated settings
    await fs.writeFile(settingsPath, JSON.stringify(settings, null, 2), 'utf8');
    console.log('‚úÖ Statusline configured successfully!');
    
  } catch (error) {
    console.error('‚ùå Failed to configure statusline:', error.message);
  }
};

const main = async () => {
  const args = process.argv.slice(2);
  
  // Handle help command
  if (args.includes('--help') || args.includes('-h')) {
    showHelp();
    return;
  }
  
  // Handle version command
  if (args.includes('--version') || args.includes('-v')) {
    const packageJson = require('../package.json');
    console.log(packageJson.version);
    return;
  }
  
  // Handle statusline command
  if (args[0] === 'statusline') {
    const { run } = require('../lib/statusline.js');
    await run();
    return;
  }
  
  // Extract command
  const command = args[0] || 'init';
  
  // Handle update-related commands by delegating to update CLI
  if (['update', 'rollback', 'status', 'cleanup'].includes(command)) {
    const { spawn } = require('child_process');
    const updateScript = path.join(__dirname, 'update.js');
    
    // Pass all arguments to the update script
    const updateProcess = spawn('node', [updateScript, ...args], {
      stdio: 'inherit',
      cwd: process.cwd()
    });

    updateProcess.on('close', (code) => {
      process.exit(code);
    });

    updateProcess.on('error', (error) => {
      console.error(CONSTANTS.MESSAGES.UNEXPECTED_ERROR, error.message);
      process.exit(CONSTANTS.EXIT_CODE.ERROR);
    });

    return;
  }
  
  // Handle init command
  if (command !== 'init') {
    console.log(CONSTANTS.MESSAGES.UNKNOWN_COMMAND, command);
    console.log(CONSTANTS.MESSAGES.HELP_SUGGESTION);
    process.exit(CONSTANTS.EXIT_CODE.ERROR);
  }
  
  console.log(CONSTANTS.MESSAGES.INIT_START);
  logSpacing();
  
  // Check Claude CLI first
  const claudeAvailable = await validateClaude();
  if (!claudeAvailable) {
    process.exit(CONSTANTS.EXIT_CODE.ERROR);
  }
  
  const targetPath = process.cwd();
  
  // Check for legacy flag
  const useLegacyMode = args.includes('--legacy');
  
  try {
    // Prompt for statusline configuration BEFORE init
    const addStatusline = await promptForStatusline();
    
    if (useLegacyMode) {
      console.log('‚ö†Ô∏è  Using legacy mode (destructive replacement)');
      logSpacing();
      await init(targetPath, { mode: 'legacy', addStatusline });
    } else {
      console.log('üõ°Ô∏è  Using smart merge mode (preserves your content)');
      logSpacing();
      await init(targetPath, { mode: 'smart', addStatusline });
    }
    
    logWithSpacing(CONSTANTS.MESSAGES.INIT_SUCCESS);
    
    // Only configure statusline if user wanted it and it wasn't already handled during init
    if (addStatusline) {
      await configureStatusline(targetPath);
    }
    
    // Prompt for Opus model selection
    const useOpus = await promptForOpus();
    
    // Prompt for permission skip option
    const skipPermissions = await promptForPermissionSkip();
    
    console.log(CONSTANTS.MESSAGES.ANALYSIS_START);
    logSpacing();
    
    // Build claude command for immediate analysis
    const claudeCommand = buildClaudeCommand(skipPermissions, useOpus, CONSTANTS.WISH_TEXT);
    
    // Auto-trigger claude command for immediate analysis
    const claudeProcess = spawn(claudeCommand, {
      stdio: 'inherit',
      shell: true,
      cwd: targetPath
    });

    claudeProcess.on('error', (error) => {
      handleClaudeError(error, skipPermissions, useOpus);
    });

    claudeProcess.on('close', (code) => {
      showAnalysisCompletion(code, skipPermissions, useOpus);
    });
    
  } catch (error) {
    console.error(CONSTANTS.MESSAGES.INIT_FAILED, error.message);
    logSpacing();
    console.log(CONSTANTS.MESSAGES.TROUBLESHOOTING);
    console.log('   ‚Ä¢ Ensure you have write permissions in this directory');
    console.log('   ‚Ä¢ Check that Claude CLI is properly authenticated');
    console.log('   ‚Ä¢ Try running: claude auth');
    logSpacing();
    process.exit(CONSTANTS.EXIT_CODE.ERROR);
  }
};

// Handle unhandled errors gracefully
process.on('unhandledRejection', (error) => {
  exitWithError(`${CONSTANTS.MESSAGES.UNEXPECTED_ERROR} ${error.message}`);
});

process.on('uncaughtException', (error) => {
  exitWithError(`${CONSTANTS.MESSAGES.FATAL_ERROR} ${error.message}`);
});

// Only run main() if this script is executed directly, not when required by tests
if (require.main === module) {
  main();
}